# LearnFluxArchitecture
Example of how to implement an Android TODO App using Facebook Flux Architecture

https://github.com/lgvalle/android-flux-todo-app

以下和訳

Androidアプリケーションの優れたアーキテクチャを見つけることは容易ではありません。 Googleはそれをあまり気にしていないようだから、アクティビティライフサイクル管理以外のパターンについては公式な勧告はない。
しかし、アプリケーションのアーキテクチャを定義することは重要です。 それと同様に、あらゆるアプリケーションはアーキテクチャを持つ予定です。 だから、それが出現するよりも、それを定義する方が良いでしょう。

## Today: Clean Architecture

現在のトレンドは、Webアプリケーション用の2012年の叔父Bobの提案であるClean Architectureを採用することです。

クリーン・アーキテクチャーは、ほとんどのAndroidアプリのために少し工夫されているかもしれませんが。

通常、モバイルアプリはウェブアプリよりも短く生きています。モバイルテクノロジーは急速に進化しており、今日リリースされたアプリはすべて12か月で完全に非難される予定です。

モバイルアプリは通常ほとんど機能しません。ユースケースの非常に高い割合は、データを消費するためのものです。 

APIからデータを取得し、ユーザーにデータを表示します。多くの読み込み、非常に少ない書き込み。

その結果、ビジネスロジックは複雑ではありません。少なくともバックエンドアプリケーションほど複雑ではありません。あなたは、メモリ、ストレージ、一時停止、再開、ネットワーク、ロケーションなどのプラットフォームの問題に対処しなければなりません。しかし、それはあなたのアプリケーションビジネスロジックではありません。あなたはすべてのアプリにそのすべてを持っています。

だから、そこのアプリケーションのほとんどは、複雑なレイヤーの分割やジョブ優先度の実行キューのようなものから利益を得られないようです。

コードを整理し、効率的に連携し、バグを見つけやすい簡単な方法が必要なだけかもしれません。

## Introducing Flux Architecture

Flux Architectureは、FacebookがクライアントサイドWebアプリケーションを構築するために使用します。 クリーンアーキテクチャと同様に、モバイルアプリ向けではありませんが、その機能とシンプルさによって、Androidプロジェクトに非常によく適応できます。

![](https://raw.githubusercontent.com/lgvalle/lgvalle.github.io/master/public/images/flux-graph-simple.png)

Fluxを理解するには2つの重要な機能があります。

- データフローは常に単方向です。

単方向のデータフローはFluxアーキテクチャの中核であり、そのために簡単に学習できます。 また、後述するようにアプリケーションをテストする際に大きな利点があります。

- アプリケーションは3つの主要な部分に分かれています：
  - `View`：アプリケーションインターフェイス。 ユーザーの操作に応じてアクションを作成します。
  - `Dispatcher`：すべてのアクションを通過させ、すべてのストアにそれらを到達させることである中央ハブ
  - `Store`：特定のアプリケーションドメインの状態を維持します。 現在の状態に応じてアクションに応答し、ビジネスロジックを実行し、完了したら変更イベントを発行します。 このイベントは、ビューがインタフェースを更新するために使用します。
  
この3つの部分は、アクションを介して通信します。タイプによって識別され、そのアクションに関連するデータを含むシンプルなプレーンオブジェクト。

## Flux Android Architecture

Flux Androidのアーキテクチャ

Android開発でFluxの原則を使用する主な目標は、シンプルさとスケーラビリティとテストの容易さのバランスに優れたアーキテクチャを構築することです。

最初のステップは、Flux要素をAndroidアプリコンポーネントでマップすることです。

これらの要素のうちの2つは、把握して実装するのが非常に簡単です。

- `View`：アクティビティまたはフラグメント
- `Dispatcher`：イベントバス。 私は私の例でOttoを使用しますが、他の実装はうまくいくはずです。

### Actions
アクションも複雑ではありません。 それらは、2つの主な属性を持つ単純なPOJOとして実装されます：

- `Type`：イベントのタイプを識別するString。
- `Data`：このアクションのペイロードを含むマップ。

たとえば、ユーザーの詳細を表示する典型的な操作は、次のようになります。

```
Bundle data = new Bundle();
data.put("USER_ID", id);
Action action = new ViewAction("SHOW_USER", data);
```

### Store
これはおそらくFluxのコンセプトを得るのが最も難しいでしょう。

また、以前はクリーン・アーキテクチャーで作業していた場合でも、受け入れるのが難しいことがあります。これは、以前は異なるレイヤーに分かれていた責任を引き継ぐからです。

`Store`には、アプリケーションとビジネスロジックのステータスが含まれます。 リッチデータモデルに似ていますが、さまざまなオブジェクトの状態を管理できます。

`Store`はディスパッチャによって発行されたアクションに反応し、ビジネスロジックを実行し、結果として変更イベントを発行します。

`Store`のみの出力はこの単一のイベントです：変更。 ストアの内部ステータスに関心を持つ他のコンポーネントは、このイベントリスナーを介して、必要なデータを取得するために使用する必要があります。

システムの他のコンポーネントは、アプリケーションのステータスについて何も知る必要はありません。

最後に、`Store`はアプリケーションステータスを取得するためのインターフェイスを公開する必要があります。 このようにして、ビュー要素は`Store`と更新アプリケーションのUIに応答してクエリを実行できます。
